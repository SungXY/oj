/* Generated By:JavaCC: Do not edit this line. CPPParser2.java */
/* Generated By:JavaCC: Do not edit this line. CPPParser2.java */
package com.bupt.service.search.parser.cpp;

import com.bupt.service.search.node.VariableNode;

import java.util.ArrayList;
import java.util.List;

public final class CPPParser2 implements CPPParser2Constants {
  private static String vers = "v20";

  private static String id = "C++ Parser";

  private static boolean isFriend = false;

  /**�洢�ҵ��ı�������ͨ��get�������ؽ��*/
  private List <VariableNode> finder = new ArrayList < VariableNode > (); //�����洢�ڵ�����

  public List<VariableNode> getFinder() {
        return finder;
}

/**
* ���б������Һ�����������ĵ�List < VariableNode > finder
*/
  final public void runLexicalFinder() throws ParseException
  {
    //tokenlist = new ArrayList < Integer > ();
    Token mt = getToken(1);
    //Token mt = token.next;
    while (mt.kind != CPPParser2Constants.EOF)
    {
      if (mt.kind == CPPParser2Constants.ID || mt.kind == CPPParser2Constants.STRING)
      {
        finder.add(new VariableNode(mt.beginLine, mt.beginColumn, mt.endColumn, mt.toString()));
      }
      mt = token_source.getNextToken();
    }
  }

  /**
   * ���дʷ����������з���Token�Ĺ�ϣֵ
   * @throws ParseException
   
  final public void runLineLexical(DefaultCodeFile cf) throws ParseException
  {
    linetokenlist = cf.getTokenLine();
    linetokenlist.clear();
    Token mt = getToken(1);
    int hashValue = 0;
    int tempHashValue = 0;
    int tempLineNum = 0;
    String LineString = new String();
    while (mt.kind != CPPParser2Constants.EOF)
    {
      tempLineNum = mt.beginLine;
      while (mt.beginLine == tempLineNum && mt.kind != CPPParser2Constants.EOF)
      {
        LineString = LineString + " " + mt.getValue();
        mt = token_source.getNextToken();
        //System.out.println(mt.kind+" "+mt.image);
      }
      hashValue = LineString.hashCode();
      //System.out.println(LineString+" "+hashValue);
      if (hashValue != tempHashValue)
      { //ֻ������һ��hashֵ��ͬ���н��м�¼
        LineStruct temp = new LineStruct();
        temp.setLineNum(tempLineNum);
        temp.setHashValue(hashValue);
        linetokenlist.add(temp);
        tempHashValue = hashValue;
      }
      LineString = "";
    }
    //      cf.setTokenLine(linetokenlist);
  }
*/
  private static void msg(String s)
  {
    System.out.println(id + " Version " + vers + ": " + s);
  }

  public static void main(String args [])
  {
  }

  /** Generated Token Manager. */
  public CPPParser2TokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;

  /** Constructor with InputStream. */
  public CPPParser2(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CPPParser2(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CPPParser2TokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Constructor. */
  public CPPParser2(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CPPParser2TokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Constructor with generated Token Manager. */
  public CPPParser2(CPPParser2TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Reinitialise. */
  public void ReInit(CPPParser2TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      return token;
    }
    jj_nt = token;
    token = oldToken;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}

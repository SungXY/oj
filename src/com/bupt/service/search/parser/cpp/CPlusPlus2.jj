/**
 * 专门为搜索变量名而单独列出
 * Copyright (C) 2000 ITC-irst, Centro per la Ricerca Scientifica
 *                    e Tecnologica, Trento, Italy.
 *
 * Authors: Paolo Tonella and Alessandra Potrich
 * E-mail: {tonella, potrich}@itc.it
 * Date: 30/6/2000
 *
 *
 * Derived in part from the following works:
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 * Author: Sreenivasa Viswanadha
 * Date: 3/20/97
 *
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 *
 */
options
{
  //此选项将代码中的u转义符转换成对应的unicode字符，为了避免出错，先加上此选项，日后可以去掉，并改用预处理的方式实现
  JAVA_UNICODE_ESCAPE = true;
  //此选项允许代码中有中文，如果JAVA_UNICODE_ESCAPE设为false，则应该加上该选项
  //UNICODE_INPUT = true;
  //此选项使可以new出任意多个Parser对象
  STATIC = false;
  //不报告错误，可以提高效率
  ERROR_REPORTING = false;
  //自定义工厂类
  //TOKEN_FACTORY = "TokenFactory";
  //缓存token，可以提高效率，但因此不适合交互式使用
  CACHE_TOKENS = true;
  JDK_VERSION = "1.5";
}

PARSER_BEGIN(CPPParser2)
/* Generated By:JavaCC: Do not edit this line. CPPParser2.java */
package com.bupt.parser.cpp;

import java.util.ArrayList;
import java.util.List;

import com.bupt.node.VariableNode;
public final class CPPParser2
{
  private static String vers = "v20";

  private static String id = "C++ Parser";

  private static boolean isFriend = false;

  /**存储找到的变量名，通过get函数返回结果*/
  private List < VariableNode > finder = new ArrayList < VariableNode > (); //变量存储节点数组

  public List<VariableNode> getFinder() {
	return finder;
}

/**
* 运行变量查找函数，结果填充的到List < VariableNode > finder
*/
  final public void runLexicalFinder() throws ParseException
  {
    //tokenlist = new ArrayList < Integer > ();
    Token mt = getToken(1);
    //Token mt = token.next;
    while (mt.kind != CPPParser2Constants.EOF)
    {
      if (mt.kind == CPPParser2Constants.ID || mt.kind == CPPParser2Constants.STRING)
      {
        finder.add(new VariableNode(mt.beginLine, mt.beginColumn, mt.endColumn, mt.toString()));
      }
      mt = token_source.getNextToken();
    }
  }

  /**
   * 运行词法分析，按行返回Token的哈希值
   * @throws ParseException
   
  final public void runLineLexical(DefaultCodeFile cf) throws ParseException
  {
    linetokenlist = cf.getTokenLine();
    linetokenlist.clear();
    Token mt = getToken(1);
    int hashValue = 0;
    int tempHashValue = 0;
    int tempLineNum = 0;
    String LineString = new String();
    while (mt.kind != CPPParser2Constants.EOF)
    {
      tempLineNum = mt.beginLine;
      while (mt.beginLine == tempLineNum && mt.kind != CPPParser2Constants.EOF)
      {
        LineString = LineString + " " + mt.getValue();
        mt = token_source.getNextToken();
        //System.out.println(mt.kind+" "+mt.image);
      }
      hashValue = LineString.hashCode();
      //System.out.println(LineString+" "+hashValue);
      if (hashValue != tempHashValue)
      { //只对与上一行hash值不同的行进行记录
        LineStruct temp = new LineStruct();
        temp.setLineNum(tempLineNum);
        temp.setHashValue(hashValue);
        linetokenlist.add(temp);
        tempHashValue = hashValue;
      }
      LineString = "";
    }
    //      cf.setTokenLine(linetokenlist);
  }
*/
  private static void msg(String s)
  {
    System.out.println(id + " Version " + vers + ": " + s);
  }

  public static void main(String args [])
  {
  }
}

PARSER_END(CPPParser2)

TOKEN_MGR_DECLS :
{
  static int beginLine;

  static int beginCol;

  static boolean lineDirective = false;

  static void resetBeginLineCol()
  {
  }
}

SKIP :
{
  " "
| 
  "\t"
| 
  "\n"
| 
  "//" : IN_LINE_COMMENT
| 
  "/*" : IN_COMMENT
| 
  < "#" ([ " ", "\t" ])* "line" > : LINE_NUMBER
| 
  < "#" ([ " ", "\t" ])* [ "0"-"9" ] >
  {
    input_stream.backup(1);
  }
  : LINE_NUMBER
| 
  "#" : PREPROCESSOR_OUTPUT
}

< LINE_NUMBER >
SKIP :
{
  < ([ "0"-"9" ])+ >
  {
    try
    {
      beginLine = Integer.parseInt(image.toString());
    }
    catch (NumberFormatException e)
    {} // Will never come here.
  }
  : LINE_DIRECTIVE
}

< LINE_DIRECTIVE >
SKIP :
{
  "\n" : AFTER_LINE_DIRECTIVE
| 
  < ~[ ] >
}

< AFTER_LINE_DIRECTIVE >
SKIP :
{
  < ~[ ] >
  {
    input_stream.adjustBeginLineColumn(beginLine, 1);
    input_stream.backup(1);
  }
  : DEFAULT
}

< IN_LINE_COMMENT >
SKIP :
{
  "\n" : DEFAULT
}

< IN_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< IN_COMMENT >
SKIP :
{
  "*/" : DEFAULT
}

< IN_COMMENT >
MORE :
{
  < ~[ ] >
}

< PREPROCESSOR_OUTPUT >
SKIP :
{
  "\n" : DEFAULT
}

< PREPROCESSOR_OUTPUT >
MORE :
{
  < ~[ ] >
}

TOKEN :
{
  < LCURLYBRACE : "{" >
| < RCURLYBRACE : "}" >
| < LSQUAREBRACKET : "[" >
| < RSQUAREBRACKET : "]" >
| < LPARENTHESIS : "(" >
| < RPARENTHESIS : ")" >
| < SCOPE : "::" >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < QUESTIONMARK : "?" >
| < ELLIPSIS : "..." >
| < ASSIGNEQUAL : "=" >
| < TIMESEQUAL : "*=" >
| < DIVIDEEQUAL : "/=" >
| < MODEQUAL : "%=" >
| < PLUSEQUAL : "+=" >
| < MINUSEQUAL : "-=" >
| < SHIFTLEFTEQUAL : "<<=" >
| < SHIFTRIGHTEQUAL : ">>=" >
| < BITWISEANDEQUAL : "&=" >
| < BITWISEXOREQUAL : "^=" >
| < BITWISEOREQUAL : "|=" >
| < OR : "||" >
| < AND : "&&" >
| < BITWISEOR : "|" >
| < BITWISEXOR : "^" >
| < AMPERSAND : "&" >
| < EQUAL : "==" >
| < NOTEQUAL : "!=" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < LESSTHANOREQUALTO : "<=" >
| < GREATERTHANOREQUALTO : ">=" >
| < SHIFTLEFT : "<<" >
| < SHIFTRIGHT : ">>" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < DIVIDE : "/" >
| < MOD : "%" >
| < PLUSPLUS : "++" >
| < MINUSMINUS : "--" >
| < TILDE : "~" >
| < NOT : "!" >
| < DOT : "." >
| < POINTERTO : "->" >
| < DOTSTAR : ".*" >
| < ARROWSTAR : "->*" >
| < AUTO : "auto" >
| < BREAK : "break" >
| < CASE : "case" >
| < CATCH : "catch" >
| < CHAR : "char" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < _DEFAULT : "default" >
| < DELETE : "delete" >
| < DO : "do" >
| < DOUBLE : "double" >
| < ELSE : "else" >
| < ENUM : "enum" >
| < EXTERN : "extern" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FRIEND : "friend" >
| < GOTO : "goto" >
| < IF : "if" >
| < INLINE : "inline" >
| < MUTABLE : "mutable" >
| < EXPLICIT : "explicit" >
| < DYNAMIC_CAST : "dynamic_cast" >
| < STATIC_CAST : "static_cast" >
| < REINTERPRET_CAST : "reinterpret_cast" >
| < CONST_CAST : "const_cast" >
| < TYPEID : "typeid" >
| < WCHAR_T : "wchar_t" >
| < BOOL : "bool" >
| < INT : "int" >
| < LONG : "long" >
| < NEW : "new" >
| < PRIVATE : "private" >
| < PROTECTED : "protected" >
| < PUBLIC : "public" >
| < REDECLARED : "redeclared" >
| < REGISTER : "register" >
| < RETURN : "return" >
| < SHORT : "short" >
| < SIGNED : "signed" >
| < SIZEOF : "sizeof" >
| < STATIC : "static" >
| < STRUCT : "struct" >
| < CLASS : "class" >
| < TYPENAME : "typename" >
| < SWITCH : "switch" >
| < TEMPLATE : "template" >
| < EXPORT : "export" >
| < THIS : "this" >
| < TRY : "try" >
| < TYPEDEF : "typedef" >
| < UNION : "union" >
| < UNSIGNED : "unsigned" >
| < VIRTUAL : "virtual" >
| < VOID : "void" >
| < VOLATILE : "volatile" >
| < WHILE : "while" >
| < OPERATOR : "operator" >
| < TRUETOK : "true" >
| < FALSETOK : "false" >
| < THROW : "throw" >
| < BOOLEAN :
    (
      "true"
    | "false"
    ) >
}

TOKEN [ IGNORE_CASE ] :
{
  < OCTALINT : "0" ([ "0"-"7" ])* >
| < OCTALLONG : < OCTALINT > "l" >
| < UNSIGNED_OCTALINT : < OCTALINT > "u" >
| < UNSIGNED_OCTALLONG :
    < OCTALINT >
    (
      "ul"
    | "lu"
    ) >
| < DECIMALINT : [ "1"-"9" ] ([ "0"-"9" ])* >
| < DECIMALLONG : < DECIMALINT > [ "u", "l" ] >
| < UNSIGNED_DECIMALINT : < DECIMALINT > "u" >
| < UNSIGNED_DECIMALLONG :
    < DECIMALINT >
    (
      "ul"
    | "lu"
    ) >
| < HEXADECIMALINT : "0x" ([ "0"-"9", "a"-"f" ])+ >
| < HEXADECIMALLONG : < HEXADECIMALINT > ([ "u", "l" ])? >
| < UNSIGNED_HEXADECIMALINT : < HEXADECIMALINT > "u" >
| < UNSIGNED_HEXADECIMALLONG :
    < HEXADECIMALINT >
    (
      "ul"
    | "lu"
    ) >
| < FLOATONE :
    (
      ([ "0"-"9" ])+ "." ([ "0"-"9" ])*
    | ([ "0"-"9" ])* "." ([ "0"-"9" ])+
    )
    (
      "e" ([ "-", "+" ])? ([ "0"-"9" ])+
    )?
    ([ "f", "l" ])? >
| < FLOATTWO : ([ "0"-"9" ])+ "e" ([ "-", "+" ])? ([ "0"-"9" ])+ ([ "f", "l" ])? >
}

TOKEN :
{
  < CHARACTER :
    ("L")? "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "v", "b", "r", "f", "a", "\\", "?", "'", "\"" ]
        | 
          "0" ([ "0"-"7" ])*
        | 
          [ "1"-"9" ] ([ "0"-"9" ])*
        |
          (
            "0x"
          | "0X"
          )
          ([ "0"-"9", "a"-"f", "A"-"F" ])+
        )
      )
    )*
    "'" >
| < STRING :
    ("L")? "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "v", "b", "r", "f", "a", "\\", "?", "'", "\"" ]
        | 
          "0" ([ "0"-"7" ])*
        | 
          [ "1"-"9" ] ([ "0"-"9" ])*
        |
          (
            "0x"
          | "0X"
          )
          ([ "0"-"9", "a"-"f", "A"-"F" ])+
        )
      )
    )*
    "\"" >
}

TOKEN :
{
  < ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}
